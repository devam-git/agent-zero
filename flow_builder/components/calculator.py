CALCULATOR_TEMPLATE = {
    "description": "Perform basic arithmetic operations on a given expression.",
    "display_name": "Calculator",
    "icon": "calculator",
    "base_classes": ["Data"],
    "beta": False,
    "conditional_paths": [],
    "custom_fields": {},
    "documentation": "",
    "edited": False,
    "frozen": False,
    "legacy": False,
    "lf_version": "1.4.3",
    "metadata": {},
    "output_types": [],
    "pinned": False,
    "category": "tools",
    "key": "CalculatorComponent",
    "official": False,
    "minimized": False,
    "outputs": [{
        "allows_loop": False,
        "cache": True,
        "display_name": "Toolset",
        "group_outputs": False,
        "hidden": None,
        "method": "to_toolkit",
        "name": "component_as_tool",
        "options": None,
        "required_inputs": None,
        "selected": "Tool",
        "tool_mode": True,
        "types": ["Tool"],
        "value": "__UNDEFINED__"
    }],
    "field_order": [
        "expression"
    ],
    "template": {
        "_type": "Component",
        "expression": {
            "_input_type": "MessageTextInput",
            "advanced": False,
            "display_name": "Expression",
            "dynamic": False,
            "info": "The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').",
            "input_types": ["Message"],
            "list": False,
            "list_add_label": "Add More",
            "load_from_db": False,
            "name": "expression",
            "placeholder": "",
            "required": False,
            "show": True,
            "title_case": False,
            "tool_mode": True,
            "trace_as_input": True,
            "trace_as_metadata": True,
            "type": "str",
            "value": ""
        },
        "code": {
            "advanced": True,
            "dynamic": True,
            "fileTypes": [],
            "file_path": "",
            "info": "",
            "list": False,
            "load_from_db": False,
            "multiline": True,
            "name": "code",
            "password": False,
            "placeholder": "",
            "required": True,
            "show": True,
            "title_case": False,
            "type": "code",
            "value": "import ast\nimport operator\nfrom collections.abc import Callable\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\n\n\nclass CalculatorComponent(Component):\n    display_name = \"Calculator\"\n    description = \"Perform basic arithmetic operations on a given expression.\"\n    icon = \"calculator\"\n\n    # Cache operators dictionary as a class variable\n    OPERATORS: dict[type[ast.operator], Callable] = {\n        ast.Add: operator.add,\n        ast.Sub: operator.sub,\n        ast.Mult: operator.mul,\n        ast.Div: operator.truediv,\n        ast.Pow: operator.pow,\n    }\n\n    inputs = [\n        MessageTextInput(\n            name=\"expression\",\n            display_name=\"Expression\",\n            info=\"The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').\",\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"result\", type_=Data, method=\"evaluate_expression\"),\n    ]\n\n    def _eval_expr(self, node: ast.AST) -> float:\n        \"\"\"Evaluate an AST node recursively.\"\"\"\n        if isinstance(node, ast.Constant):\n            if isinstance(node.value, int | float):\n                return float(node.value)\n            error_msg = f\"Unsupported constant type: {type(node.value).__name__}\"\n            raise TypeError(error_msg)\n        if isinstance(node, ast.Num):  # For backwards compatibility\n            if isinstance(node.n, int | float):\n                return float(node.n)\n            error_msg = f\"Unsupported number type: {type(node.n).__name__}\"\n            raise TypeError(error_msg)\n\n        if isinstance(node, ast.BinOp):\n            op_type = type(node.op)\n            if op_type not in self.OPERATORS:\n                error_msg = f\"Unsupported binary operator: {op_type.__name__}\"\n                raise TypeError(error_msg)\n\n            left = self._eval_expr(node.left)\n            right = self._eval_expr(node.right)\n            return self.OPERATORS[op_type](left, right)\n\n        error_msg = f\"Unsupported operation or expression type: {type(node).__name__}\"\n        raise TypeError(error_msg)\n\n    def evaluate_expression(self) -> Data:\n        \"\"\"Evaluate the mathematical expression and return the result.\"\"\"\n        try:\n            tree = ast.parse(self.expression, mode=\"eval\")\n            result = self._eval_expr(tree.body)\n\n            formatted_result = f\"{float(result):.6f}\".rstrip(\"0\").rstrip(\".\")\n            self.log(f\"Calculation result: {formatted_result}\")\n\n            self.status = formatted_result\n            return Data(data={\"result\": formatted_result})\n\n        except ZeroDivisionError:\n            error_message = \"Error: Division by zero\"\n            self.status = error_message\n            return Data(data={\"error\": error_message, \"input\": self.expression})\n\n        except (SyntaxError, TypeError, KeyError, ValueError, AttributeError, OverflowError) as e:\n            error_message = f\"Invalid expression: {e!s}\"\n            self.status = error_message\n            return Data(data={\"error\": error_message, \"input\": self.expression})\n\n    def build(self):\n        \"\"\"Return the main evaluation function.\"\"\"\n        return self.evaluate_expression"
        }
    },
    "tool_mode": False,
    "selected_output": "component_as_tool"
}